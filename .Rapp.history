test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+testage + herd2+ cluster(animal) + testage:start, data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage + herd2+ cluster(animal) + herd2:start, data=data); summary(test.mod) # 244.4092
#############################################################
#############################################################
# Models- BRUCELLOSIS INCIDENCE#
#############################################################
#############################################################
data<- read.csv("~/Documents/postdoc_buffology/Last-Thesis-Chapter!!!!!!/final_datasets_copied_from_phdfolder/brucellosis_incidence.csv")#
data$animal<-as.character(data$animal)#
data$age_yr2<- floor(data$age_yr)
data$age4<- NA#
data$age4[data$age_yr <4] <- "young"#
data$age4[data$age_yr >= 4] <- "old"#
data$age5<- NA#
data$age5[data$age_yr < 5] <- "young"#
data$age5[data$age_yr >= 5] <- "old"#
data$age2 <- NA#
data$age2[data$age_yr < 2] <- "young"#
data$age2[data$age_yr >= 2] <- "old"#
data$age3p <- NA#
data$age3p[data$age_yr < 3] <- "young"#
data$age3p[data$age_yr >= 3 & data$age_yr <5] <- "adult"#
data$age3p[data$age_yr >=5] <- "old"#
data$age2p <- NA#
data$age2p[data$age_yr < 2] <- "young"#
data$age2p[data$age_yr >= 2 & data$age_yr <4] <- "adult"#
data$age2p[data$age_yr >=4] <- "old"
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+age5+TB_3*herd2+ cluster(animal), data=data); summary(test.mod)  # 248.9
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*testage+herd2+ cluster(animal), data=data2); summary(test.mod) #244.4
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+age4+TB_3*herd2+ cluster(animal), data=data); summary(test.mod) # 247.3
# And if use categories...above (REPORTED WITH CONTINUOUS AGE...)#
data$testage<- NA#
data$testage[data$age_yr <3] <- "young"#
data$testage[data$age_yr >= 3] <- "old"
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*testage+herd2+ cluster(animal), data=data2); summary(test.mod) #244.4
data$testage<- NA#
data$testage[data$age_yr <3] <- "young"#
data$testage[data$age_yr >= 3] <- "old"
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+herd2+testage+ cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage + testage:stop+ cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage + herdd2:stop+ cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage + herd2:stop+ cluster(animal), data=data); summary(test.mod) # 248.75
table(data$testageyoung)
table(data$testage)
table(data$age_yr)
table(data$age_yr2)
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+age2p + herd2:stop+ cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+age2p + cluster(animal), data=data); summary(test.mod) # 248.75
data[data$convert.time==1 & data$age_yr2 < 5]
data[data$convert.time==1 & data$age_yr2 < 5,]
length(data$convert.time[data$convert.time==1])
length(data$convert.time[data$convert.time==1 & data$age_yr2 < 5,])
length(data$convert.time[data$convert.time==1 & data$age_yr2 < 5])
length(data$convert.time[data$convert.time==1 & data$age_yr2 < 3])
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+age3p + cluster(animal), data=data); summary(test.mod) # 248.75
table(data$age_yr)
table(data$age_yr2)
?coxph
temp<-cox.zph(test.mod)#
print(temp);#
par(mfrow=c(2,3))#
 plot(temp)
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage + cluster(animal), data=data); summary(test.mod) # 248.75
temp<-cox.zph(test.mod)#
print(temp);#
par(mfrow=c(2,3))#
 plot(temp)
res<-resid(test.mod)#
#
# get predicted#
predRes <- predict(test.mod, type="risk")#
head(predRes, n=10)#
Shat2 <- survexp(~ TB_3+ brucella, ratetable=test.mod, data=data3)#
with(Shat2, head(data.frame(time, surv), n=4))
predRes <- predict(test.mod, type="risk")#
head(predRes, n=10)#
Shat2 <- survexp(~ TB_3+ brucella, ratetable=test.mod, data=data)#
with(Shat2, head(data.frame(time, surv), n=4))
# get predicted#
predRes <- predict(test.mod, type="risk")#
head(predRes, n=10)#
Shat2 <- survexp(~ TB_3, ratetable=test.mod, data=data)#
with(Shat2, head(data.frame(time, surv), n=4))
?survexp
summary(test.mod)
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage + herd2:start + cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+herd2+testage + herd2:start + cluster(animal), data=data); summary(test.mod) # 248.75
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*testage+herd2+ cluster(animal), data=data2); summary(test.mod) #244.4
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*testage+herd2+ cluster(animal), data=data); summary(test.mod) #244.4
#############################################################
#############################################################
# Models- BRUCELLOSIS INCIDENCE#
#############################################################
#############################################################
data<- read.csv("~/Documents/postdoc_buffology/Last-Thesis-Chapter!!!!!!/final_datasets_copied_from_phdfolder/brucellosis_incidence.csv")#
data$animal<-as.character(data$animal)#
data$age_yr2<- floor(data$age_yr)
data$testage<- NA#
data$testage[data$age_yr <3] <- "young"#
data$testage[data$age_yr >= 3] <- "old"#
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ cluster(animal), data=data); summary(test.mod)
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+herd2+testage+ cluster(animal), data=data); summary(test.mod) # 248.75
temp<-cox.zph(test.mod)#
print(temp);#
par(mfrow=c(2,3))#
 plot(temp)
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+herd2:stop cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+herd2:stop + cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+herd2*TB:stop + cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+herd2*TB_3:stop + cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ herd2:stop+ herd2:TB_3:stop + cluster(animal), data=data); summary(test.mod) # 244.4092
table(data$start)
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ cluster(animal), data=data[data$start > 6,]); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ cluster(animal), data=data[data$start < 6,]); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd+testage+ cluster(animal), data=data[data$start < 6,]); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ herd2:stop+ herd2:stop + cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd+testage+ herd:stop+ cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ cluster(animal), data=data); summary(test.mod) # 244.4092
#############################################################
data<- read.csv("~/Documents/postdoc_buffology/Last-Thesis-Chapter!!!!!!/final_datasets_copied_from_phdfolder/tb_incidence.csv")#
data$animal<-as.character(data$animal)#
data$age_yr2<- floor(data$age_yr)
data$testage<- NA#
data$testage[data$age_yr <3] <- "young"#
data$testage[data$age_yr >= 3] <- "old"#
data$age4<- NA#
data$age4[data$age_yr <4] <- "young"#
data$age4[data$age_yr >= 4] <- "old"#
data$age5<- NA#
data$age5[data$age_yr < 5] <- "young"#
data$age5[data$age_yr >= 5] <- "old"
test.mod<-coxph(Surv(start, stop, convert.time)~ brucella +herd2+testage+ cluster(animal), data=data); summary(test.mod)
? cox.zph
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+age4+TB_3*herd2+ cluster(animal), data=data); summary(test.mod) # 247.3
#############################################################
#############################################################
# Models- BRUCELLOSIS INCIDENCE#
#############################################################
#############################################################
data<- read.csv("~/Documents/postdoc_buffology/Last-Thesis-Chapter!!!!!!/final_datasets_copied_from_phdfolder/brucellosis_incidence.csv")#
data$animal<-as.character(data$animal)#
data$age_yr2<- floor(data$age_yr)
# And if use categories...above (REPORTED WITH CONTINUOUS AGE...)#
data$testage<- NA#
data$testage[data$age_yr <3] <- "young"#
data$testage[data$age_yr >= 3] <- "old"#
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3*herd2+testage+ cluster(animal), data=data); summary(test.mod) # 244.4092
test.mod<-coxph(Surv(start, stop, convert.time)~ TB_3+testage+ cluster(animal), data=data); summary(test.mod) # 244.4092
###########################################################
# 1) Load fixed parameters and model; diffeqs; stochastic version#
# 2) Load Data to fit to and data for evaluation#
# 3) Fit Deterministic Version to overall prevalence#
### Four models fit, one for each assumption about recovery, mortality#
# 4) Fit Determinisit Version to overall prevlalence after systematically varying epsilon, gamma#
# 5) Plot deterministic version of model predictions#
# 6) Plot stochastic version of model predictions#
##############################################################
##############################################################
##############################################################
##############################################################
1) Load fixed parameters, model#
##############################################################
##############################################################
require("deSolve")#
library("plyr")#
library("ggplot2")#
set.seed(5)#
# get fixed.params & fixed.params.recov#
source('~/GitHub/bTB-bruc-co-infection-ms/fixed_parameters_recovery.R', chdir = TRUE)#
source('~/GitHub/bTB-bruc-co-infection-ms/fixed_parameters_norecovery.R', chdir = TRUE)#
#
# rhs function, determinitic model, no agestr#
source('~/GitHub/bTB-bruc-co-infection-ms/rhs.R', chdir = TRUE) #
# functions to run the stochastic co-infection model#
source('~/GitHub/bTB-bruc-co-infection-ms/run_stochastic_coinfection_model.R', chdir = TRUE)#
source('~/GitHub/bTB-bruc-co-infection-ms/rhs_optim.R', chdir = TRUE)
ls()
fixed.params.recov
fixed.params
# functions required to interpret results#
plot_raw_numbers = function(sol){#
	plot(sol$time, sol$S, col= "black", type= 'l', ylim = c(0, 1200), ylab = "Number of animals", xlab = "Time (in years)")#
	lines(sol$time, sol$It, col= "red")#
	lines(sol$time, sol$Ib, col= "blue")#
	lines(sol$time, sol$Ic, col= "green")#
	lines(sol$time, sol$R, col = "orange")#
	lines(sol$time, sol$Rc, col = "pink")#
	legend("topright", legend = c("S", "It", "Ib", "Ic", "R", "Rc"), col = c("black", "red", "blue", "green", "orange", "pink"), bty="n", lty = 1)#
}#
#
groom_sol = function(sol){#
	colnames(sol) <- c("times", "S", "It", "Ib", "Ic", "R", "Rc") #
	sol$N <- sol$S + sol$It + sol$Ib + sol$Ic + sol$R + sol$Rc#
	sol$TBprev <- (sol$It + sol$Ic + sol$Rc) / sol$N#
	sol$Brucprev <- (sol$Ib + sol$R + sol$Ic + sol$Rc) / sol$N#
	sol$propTB_co <- (sol$Ic + sol$Rc) / (sol$It + sol$Ic + sol$Rc)#
	sol$propBruc_co <- (sol$Ic + sol$Rc) / (sol$Ib + sol$R + sol$Ic + sol$Rc)#
	return(sol)#
}#
#
get_starting_eqbruc = function(params){#
	x0 <- c(S = params['K'][[1]]-100, It = 0, Ib = 50, Ic = 0, R = 50, Rc = 0)#
	times <- seq(0, 1000, 1)#
	sol <- as.data.frame(ode(x0, times, rhs, params))#
	out <- c(S = sol$S[length(times)], #
		It = 0, Ib = sol$Ib[length(times)], Ic = 0,#
		R = sol$R[length(times)], Rc = 0)#
	return(out)#
}#
# data for fitting, currently using overall, switch to herd specific later#
prevTBobs <- 0.27; prevBobs <- 0.34#
prevTBobsLS <- 0.27; prevBobsLS <- 0.35#
prevTBobsCB <- 0.28; prevBobsCB <- 0.33
objective = function(params.est){#
	# params.est = 2 long = c(betaB, betaT)#
	params <- c(params.fixed, betaB = params.est[1], betaT = params.est[2], rhoB = 4.05, rhoT = 1.3)#
	# seed from endemic brucellosis conditions, 10 bTB positive buffalo#
	x0 = get_starting_eqbruc(params = c(params))#
	x0[[2]] <- x0[[2]] + 10#
	x0[[1]] <- x0[[1]] - 10  #
	sol <- as.data.frame(ode(x0, times, rhs_optim, params)) # rhs_optim shouldn't get betap's#
	df <- groom_sol(sol)#
	prevTB <- df$TBprev[length(df[,1])]#
	prevB <- df$Brucprev[length(df[,1])]#
	error <- sqrt(((prevTBobs - prevTB)^2 + (prevBobs - prevB)^2))#
	return (error)#
}#
betaB = 0.003; betaT = 0.0006#
times <- seq(0, 100, 1)#
params.fixed = c(fixed.params, gamma=1/2)
params.fixed = c(fixed.params, gamma=1/2)#
parH1_1 <- optim(c(0.001, 0.001), objective)#
paramsH1.1 <- c(params.fixed, betab = parH1_1$par[1], betat = parH1_1$par[2])  # run with rhs_optim#
#
# H1_2: no recovery from mortality rates!, #
params.fixed = c(fixed.params.recov, gamma = 1/2)#
parH1_2 <- optim(c(0.001, 0.001), objective) #
paramsH1.2 <- c(params.fixed, betab = parH1_2$par[1], betat = parH1_2$par[2])
objective = function(params.est){#
	# params.est = 2 long = c(betaB, betaT, gamma)#
	params <- c(params.fixed, betaB = params.est[1], betaT = params.est[2], gamma = params.est[3], rhoB = 4.05, rhoT = 1.3)#
	# seed from endemic brucellosis conditions, 10 bTB positive buffalo#
	x0 = get_starting_eqbruc(params = c(params))  #
	x0[[2]] <- x0[[2]] + 10#
	x0[[1]] <- x0[[1]] - 10  #
	sol <- as.data.frame(ode(x0, times, rhs_optim, params)) # rhs_optim shouldn't get betap's#
	df <- groom_sol(sol)#
	prevTB <- df$TBprev[length(df[,1])]#
	prevB <- df$Brucprev[length(df[,1])]#
	error <- sqrt(((prevTBobs - prevTB)^2 + (prevBobs - prevB)^2))#
	return (error)#
}
df <- data.frame(paramsestimated = c(rep("transmission", 2), rep("tranmssion&recovery", 2)), #
	recoveryassumption = c("none", "recovery", "none", "recovery"),#
	betaB = c(paramsH1.1[[17]], paramsH1.2[[17]], paramsH2.1[[17]], paramsH2.2[[17]]),#
	betaT = c(paramsH1.1[[18]], paramsH1.2[[18]], paramsH2.1[[18]], paramsH2.2[[18]]), #
	gamma = c(0.5, 0.5, paramsH2.1[[16]], paramsH2.2[[16]]),#
	TBprev = NA, Brucprev = NA, TBprevinS = NA, TBprevinCo = NA, BrucprevinS = NA, BrucprevinCo = NA)#
get_sum_stats = function(recoveryassumption, params.variable){#
	if(recoveryassumption == "none"){#
		params = c(fixed.params, params.variable)#
	}#
	if(recoveryassumption == "recovery"){#
		params = c(fixed.params.recov, params.variable)#
	}#
	times <- seq(0, 1000, 1)#
	x0 = get_starting_eqbruc(params = params)#
	x0[[2]] <- x0[[2]] + 10#
	x0[[1]] <- x0[[1]] - 10  #
	sol <- as.data.frame(ode(x0, times, rhs, params))#
	df <- groom_sol(sol)#
	df$TBprevinS <- df$It / (df$S + df$It)#
	df$TBprevinCo <- (df$Ic + df$Rc) / (df$Ib + df$R + df$Ic + df$Rc)#
	df$BrucprevinS <- (df$Ib + df$R) / (df$S + df$Ib + df$R)#
	df$BrucprevinCo <- (df$Ic + df$Rc) / (df$Ic + df$Rc + df$It)#
	sumstats <- c(#
	df$TBprev[length(df$TBprev)], #TB prev overall#
	df$Brucprev[length(df$Brucprev)], #Bruc prev overall#
	df$TBprevinS[length(df$TBprevinS)],#
	df$TBprevinCo[length(df$TBprevinCo)],#
	df$BrucprevinS[length(df$BrucprevinS)],#
	df$BrucprevinCo[length(df$BrucprevinCo)]	)#
#
	return(sumstats)#
}#
# fill with predictions!#
df$recoveryassumption <- as.character(df$recoveryassumption)#
for (i in 1:length(df[,1])){#
	ra <- df$recoveryassumption[i]#
	params.variable <- c(gamma = df$gamma[i], betaB = df$betaB[i], betaT = df$betaT[i],#
		rhoB = 3.8, rhoT = 1)#
	df[i,c(6:11)] <- get_sum_stats(recoveryassumption = ra, #
		params.variable = params.variable)#
	rm(ra, params.variable)#
}
betaB = 0.0003; betaT = 0.0006; gamma = 1/2#
# H1: no recovery from mortality rates!,#
params.fixed = c(fixed.params)#
parH2_1 <- optim(c(0.0003, 0.0001, 0.5), objective)  #
parH2_1.1 <- optim(c(0.0001, 0.0001, 0.1), objective) # get different values... based on initials.  Don't estimate both!
# H2: recovery from mortality rates!, #
params.fixed = c(fixed.params.recov)#
parH2_2 <- optim(c(0.0001, 0.0001, 0.1), objective)#
paramsH2.2 <- c(params.fixed, gamma = parH2_2$par[3], betab = parH2_2$par[1], betat = parH2_2$par[2])  #
df <- data.frame(paramsestimated = c(rep("transmission", 2), rep("tranmssion&recovery", 2)), #
	recoveryassumption = c("none", "recovery", "none", "recovery"),#
	betaB = c(paramsH1.1[[17]], paramsH1.2[[17]], paramsH2.1[[17]], paramsH2.2[[17]]),#
	betaT = c(paramsH1.1[[18]], paramsH1.2[[18]], paramsH2.1[[18]], paramsH2.2[[18]]), #
	gamma = c(0.5, 0.5, paramsH2.1[[16]], paramsH2.2[[16]]),#
	TBprev = NA, Brucprev = NA, TBprevinS = NA, TBprevinCo = NA, BrucprevinS = NA, BrucprevinCo = NA)
parH2_2 <- optim(c(0.0001, 0.001, 0.1), objective)
paramsH2.2 <- c(params.fixed, gamma = parH2_2$par[3], betab = parH2_2$par[1], betat = parH2_2$par[2])
df <- data.frame(paramsestimated = c(rep("transmission", 2), rep("tranmssion&recovery", 2)), #
	recoveryassumption = c("none", "recovery", "none", "recovery"),#
	betaB = c(paramsH1.1[[17]], paramsH1.2[[17]], paramsH2.1[[17]], paramsH2.2[[17]]),#
	betaT = c(paramsH1.1[[18]], paramsH1.2[[18]], paramsH2.1[[18]], paramsH2.2[[18]]), #
	gamma = c(0.5, 0.5, paramsH2.1[[16]], paramsH2.2[[16]]),#
	TBprev = NA, Brucprev = NA, TBprevinS = NA, TBprevinCo = NA, BrucprevinS = NA, BrucprevinCo = NA)
paramsH2.1 <- c(params.fixed, gamma = parH2_1.1$par[3], betab = parH2_1.1$par[1], betat = parH2_1$par[2])
df <- data.frame(paramsestimated = c(rep("transmission", 2), rep("tranmssion&recovery", 2)), #
	recoveryassumption = c("none", "recovery", "none", "recovery"),#
	betaB = c(paramsH1.1[[17]], paramsH1.2[[17]], paramsH2.1[[17]], paramsH2.2[[17]]),#
	betaT = c(paramsH1.1[[18]], paramsH1.2[[18]], paramsH2.1[[18]], paramsH2.2[[18]]), #
	gamma = c(0.5, 0.5, paramsH2.1[[16]], paramsH2.2[[16]]),#
	TBprev = NA, Brucprev = NA, TBprevinS = NA, TBprevinCo = NA, BrucprevinS = NA, BrucprevinCo = NA)
get_sum_stats = function(recoveryassumption, params.variable){#
	if(recoveryassumption == "none"){#
		params = c(fixed.params, params.variable)#
	}#
	if(recoveryassumption == "recovery"){#
		params = c(fixed.params.recov, params.variable)#
	}#
	times <- seq(0, 1000, 1)#
	x0 = get_starting_eqbruc(params = params)#
	x0[[2]] <- x0[[2]] + 10#
	x0[[1]] <- x0[[1]] - 10  #
	sol <- as.data.frame(ode(x0, times, rhs, params))#
	df <- groom_sol(sol)#
	df$TBprevinS <- df$It / (df$S + df$It)#
	df$TBprevinCo <- (df$Ic + df$Rc) / (df$Ib + df$R + df$Ic + df$Rc)#
	df$BrucprevinS <- (df$Ib + df$R) / (df$S + df$Ib + df$R)#
	df$BrucprevinCo <- (df$Ic + df$Rc) / (df$Ic + df$Rc + df$It)#
	sumstats <- c(#
	df$TBprev[length(df$TBprev)], #TB prev overall#
	df$Brucprev[length(df$Brucprev)], #Bruc prev overall#
	df$TBprevinS[length(df$TBprevinS)],#
	df$TBprevinCo[length(df$TBprevinCo)],#
	df$BrucprevinS[length(df$BrucprevinS)],#
	df$BrucprevinCo[length(df$BrucprevinCo)]	)#
#
	return(sumstats)#
}
# fill with predictions!#
df$recoveryassumption <- as.character(df$recoveryassumption)#
for (i in 1:length(df[,1])){#
	ra <- df$recoveryassumption[i]#
	params.variable <- c(gamma = df$gamma[i], betaB = df$betaB[i], betaT = df$betaT[i],#
		rhoB = 3.8, rhoT = 1)#
	df[i,c(6:11)] <- get_sum_stats(recoveryassumption = ra, #
		params.variable = params.variable)#
	rm(ra, params.variable)#
}
df
objective = function(params.est){#
	# params.est = 2 long = c(betaB, betaT)#
	params <- c(params.fixed, betaB = params.est[1], betaT = params.est[2], rhoB = 2.1, rhoT = 1.3)#
	# seed from endemic brucellosis conditions, 10 bTB positive buffalo#
	x0 = get_starting_eqbruc(params = c(params))#
	x0[[2]] <- x0[[2]] + 10#
	x0[[1]] <- x0[[1]] - 10  #
	sol <- as.data.frame(ode(x0, times, rhs_optim, params)) # rhs_optim shouldn't get betap's#
	df <- groom_sol(sol)#
	prevTB <- df$TBprev[length(df[,1])]#
	prevB <- df$Brucprev[length(df[,1])]#
	error <- sqrt(((prevTBobs - prevTB)^2 + (prevBobs - prevB)^2))#
	return (error)#
}#
betaB = 0.003; betaT = 0.0006#
times <- seq(0, 100, 1)#
params.fixed = c(fixed.params, gamma=1/2)#
# make sure optimizer is smooth#
betatest<- seq(0.00001, 0.001, 0.00002); #
df <- data.frame(betaB = rep(betatest, 3), #
	betaT = rep(c(0.0001, 0.005, 0.001), each = length(betatest)), #
	out = NA)#
for(i in 1:length(df[,1])){#
	df$out[i] <- objective(c(df$betaB[i], df$betaT[i]))#
}
# H1_1: no recovery from mortality rates!,#
params.fixed = c(fixed.params, gamma=1/2)#
parH1_1 <- optim(c(0.001, 0.001), objective)#
paramsH1.1 <- c(params.fixed, betab = parH1_1$par[1], betat = parH1_1$par[2])  # run with rhs_optim#
#
# H1_2: no recovery from mortality rates!, #
params.fixed = c(fixed.params.recov, gamma = 1/2)#
parH1_2 <- optim(c(0.001, 0.001), objective) #
paramsH1.2 <- c(params.fixed, betab = parH1_2$par[1], betat = parH1_2$par[2])
for (i in 1:2){#
	ra <- df$recoveryassumption[i]#
	params.variable <- c(gamma = df$gamma[i], betaB = df$betaB[i], betaT = df$betaT[i],#
		rhoB = 3.8, rhoT = 1)#
	df[i,c(6:11)] <- get_sum_stats(recoveryassumption = ra, #
		params.variable = params.variable)#
	rm(ra, params.variable)#
}
df
df <- data.frame(paramsestimated = c(rep("transmission", 2), rep("tranmssion&recovery", 2)), #
	recoveryassumption = c("none", "recovery", "none", "recovery"),#
	betaB = c(paramsH1.1[[17]], paramsH1.2[[17]], paramsH2.1[[17]], paramsH2.2[[17]]),#
	betaT = c(paramsH1.1[[18]], paramsH1.2[[18]], paramsH2.1[[18]], paramsH2.2[[18]]), #
	gamma = c(0.5, 0.5, paramsH2.1[[16]], paramsH2.2[[16]]),#
	TBprev = NA, Brucprev = NA, TBprevinS = NA, TBprevinCo = NA, BrucprevinS = NA, BrucprevinCo = NA)#
get_sum_stats = function(recoveryassumption, params.variable){#
	if(recoveryassumption == "none"){#
		params = c(fixed.params, params.variable)#
	}#
	if(recoveryassumption == "recovery"){#
		params = c(fixed.params.recov, params.variable)#
	}#
	times <- seq(0, 1000, 1)#
	x0 = get_starting_eqbruc(params = params)#
	x0[[2]] <- x0[[2]] + 10#
	x0[[1]] <- x0[[1]] - 10  #
	sol <- as.data.frame(ode(x0, times, rhs, params))#
	df <- groom_sol(sol)#
	df$TBprevinS <- df$It / (df$S + df$It)#
	df$TBprevinCo <- (df$Ic + df$Rc) / (df$Ib + df$R + df$Ic + df$Rc)#
	df$BrucprevinS <- (df$Ib + df$R) / (df$S + df$Ib + df$R)#
	df$BrucprevinCo <- (df$Ic + df$Rc) / (df$Ic + df$Rc + df$It)#
	sumstats <- c(#
	df$TBprev[length(df$TBprev)], #TB prev overall#
	df$Brucprev[length(df$Brucprev)], #Bruc prev overall#
	df$TBprevinS[length(df$TBprevinS)],#
	df$TBprevinCo[length(df$TBprevinCo)],#
	df$BrucprevinS[length(df$BrucprevinS)],#
	df$BrucprevinCo[length(df$BrucprevinCo)]	)#
#
	return(sumstats)#
}
df
for (i in 1:2){#
	ra <- df$recoveryassumption[i]#
	params.variable <- c(gamma = df$gamma[i], betaB = df$betaB[i], betaT = df$betaT[i],#
		rhoB = 3.8, rhoT = 1)#
	df[i,c(6:11)] <- get_sum_stats(recoveryassumption = ra, #
		params.variable = params.variable)#
	rm(ra, params.variable)#
}
df
params
get_starting_eqbruc
rhs
params = c(params.fixed, gamma= 0.5, betaB= 0.0007853113, betaT = 0.0003092429, rhoT = 1.3, rhoB = 4.05)
get_starting_eqbruc(params = params)
(31.377+313.779) / (649.424 + 31.377 + 313.779)
params
params['betaB']
RoTB = params['betaB']* params['K']/ params['muT']
RoTB
RoTB = params['betaT']* params['K']/ params['muT']
RoTB
RoTBwithC = funcction(params, S, I, R){#
	# Input = parameters, equlibrium brucellosis conditions#
	betapT = rhoB * betaB#
	batapB = rhoT * betaT#
	Ro = (betapT * R) / (I * betapB + muT) + #
	(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
	(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
	((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
	((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
	((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
	((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
	(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
	return(Ro)#
}
RoTBwithC = funcction(params, x){#
	with(as.list(c(x, params)), {#
		# Input = parameters and x = equlibrium brucellosis conditions#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
}
RoTBwithC = function(params, x){#
	with(as.list(c(x, params)), {#
		# Input = parameters and x = equlibrium brucellosis conditions#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
}
RoTBwithC
RoTBwithC = function(params, x){#
	with(as.list(c(x, params)), {#
		# Input = parameters and x = equlibrium brucellosis conditions#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
}
RoTBwithC = function(params, x){#
	#with(as.list(c(x, params)), {#
		# Input = parameters and x = equlibrium brucellosis conditions#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	#}#
}
rhs
RoTBwithC = function(params, x){#
	with(as.list(c(x, params)), {#
		# Input = parameters and x = equlibrium brucellosis conditions#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
}
RoTBwithC = function(params, x){#
	# Input = parameters and x = equlibrium brucellosis conditions#
	with(as.list(c(x, params)), {#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
}
RoTBwithC = function(params, x){#
	# Input = parameters and x = equlibrium brucellosis conditions#
	with(as.list(c(x, params)), {#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
	}#
	return(Ro)#
}
RoTBwithC = function(params, x){#
	# Input = parameters and x = equlibrium brucellosis conditions#
	with(as.list(c(x, params)), {#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
	)#
}
params
RoB = (params['betaB'] * params['K']* (params['epsilon'] + params['muR']) ) /#
	( (params['gamma'] + params['muB']) * (params['epsilong'] + params['muR']) + params['epsilon'] * params['gamma'])
RoB
params['betaB']
params['betaT']
params[['betaT']]
RoB = (params[['betaB']] * params['K']* (params['epsilon'] + params['muR']) ) /#
	( (params['gamma'] + params['muB']) * (params['epsilon'] + params['muR']) + params['epsilon'] * params['gamma'])
RoB
RoB = (params[['betaB']] * params[['K']]* (params[['epsilon']] + params[['muR']]) ) /#
	( (params[['gamma']] + params[['muB']]) * (params[['epsilon']] + params[['muR']]) + params[['epsilon']] * params[['gamma']])
RoB
RoTBwithC = function(params, x){#
	# Input = parameters and x = equlibrium brucellosis conditions#
	with(as.list(c(x, params)), {#
		betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)#
	}#
	)#
}
get_x_analytic_endemic_brucellosis = function(params, RoB= RoB){ #
	with(as.list(c(x, params)), {#
		S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon - muR)#
		ap = (-b2 - b2 * delta - b3 * delta - b3 * (delta^2)) / K#
		bp = b * b2 + b * b3 * delta + betaB * S - #
			(r * S + r * S * delta + b2 * S + b3 * delta * S) / K#
		cp = b * S - muB * S - r * (S^2)#
		I1 = 0.5 * (b + sqrt(4 * a * c + b^2)) / a#
		I2 = 0.5 * (b + sqrt(4 * a * c + b^2)) / a #
		# R is a ratio of I#
		R1 = I1 * delta#
		R2 = I2 * delta#
#
	x = list(S= S, I1 = I1, I2 = I2, R1 = R1, R2 = R2)#
	return(x)#
	}#
	)#
}
get_x_analytic_endemic_brucellosis
get_x_analytic_endemic_brucellosis(params)
x = c(S= S, I1 = I1, I2 = I2, R1 = R1, R2 = R2)
get_x_analytic_endemic_brucellosis = function(params, RoB= RoB){ #
	with(as.list(c(x, params)), {#
		S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon - muR)#
		ap = (-b2 - b2 * delta - b3 * delta - b3 * (delta^2)) / K#
		bp = b * b2 + b * b3 * delta + betaB * S - #
			(r * S + r * S * delta + b2 * S + b3 * delta * S) / K#
		cp = b * S - muB * S - r * (S^2)#
		I1 = 0.5 * (b + sqrt(4 * a * c + b^2)) / a#
		I2 = 0.5 * (b + sqrt(4 * a * c + b^2)) / a #
		# R is a ratio of I#
		R1 = I1 * delta#
		R2 = I2 * delta#
#
		x = c(S= S, I1 = I1, I2 = I2, R1 = R1, R2 = R2)#
	return(x)#
	}#
	)#
}#
x = get_x_analytic_endemic_brucellosis(params)
get_x_analytic_endemic_brucellosis = function(params, RoB= RoB){ #
	with(as.list(c(params)), {#
		S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon - muR)#
		ap = (-b2 - b2 * delta - b3 * delta - b3 * (delta^2)) / K#
		bp = b * b2 + b * b3 * delta + betaB * S - #
			(r * S + r * S * delta + b2 * S + b3 * delta * S) / K#
		cp = b * S - muB * S - r * (S^2)#
		I1 = 0.5 * (b + sqrt(4 * a * c + b^2)) / a#
		I2 = 0.5 * (b + sqrt(4 * a * c + b^2)) / a #
		# R is a ratio of I#
		R1 = I1 * delta#
		R2 = I2 * delta#
#
		x = c(S= S, I1 = I1, I2 = I2, R1 = R1, R2 = R2)#
	return(x)#
	}#
	)#
}
get_x_analytic_endemic_brucellosis(params)
params
params
b1
b2
b3
b
b5
r
K
mu5
muB
muS
muT
muR
muRC
epsilon
gamma
params.fixed
S
S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon - muR)#
		ap = (-b2 - b2 * delta - b3 * delta - b3 * (delta^2)) / K#
		bp = b * b2 + b * b3 * delta + betaB * S - #
			(r * S + r * S * delta + b2 * S + b3 * delta * S) / K#
		cp = b * S - muB * S - r * (S^2)
S
RoB
delta
gamma
epsilon
muR
I2 = 0.5 * (b - sqrt(4 * a * c + b^2)) / a
I1 = 0.5 * (bp + sqrt(4 * ap * cp + bp^2)) / ap#
		I2 = 0.5 * (bp - sqrt(4 * ap * cp + bp^2)) / ap
I1
I2
I = max(I1, I2)
I
I*delta
delta = gamma / (epsilon + muR)
delta
ap = (-b2 - b2 * delta - b3 * delta - b3 * (delta^2)) * r / K
bp = b * b2 + b * b3 * delta + betaB * S - #
			(r * S + r * S * delta + b2 * S * r + b3 * delta * S * r) / K
delta = gamma / (epsilon + muR)#
		ap = (-b2 - b2 * delta - b3 * delta - b3 * (delta^2)) * r / K#
		bp = b * b2 + b * b3 * delta + betaB * S - #
			(r * S + r * S * delta + b2 * S * r + b3 * delta * S * r) / K#
		cp = b * S - muS * S - r * (S^2)#
		I1 = 0.5 * (bp + sqrt(4 * ap * cp + bp^2)) / ap#
		I2 = 0.5 * (bp - sqrt(4 * ap * cp + bp^2)) / ap
I1
I2
delta
b2
b2*delta
bp
cp
S
b
b*S - muS * S
b*S - muS * S - r * S^2
cp
bp
.5 * bp/ap
ap
I1 = 0.5 * (- bp + sqrt(bp^2 - 4 * ap * cp )) / ap
I2 = 0.5 * (- bp - sqrt(bp^2 - 4 * ap * cp )) / ap
bp
bp2
bp&2
bp^2
ap
cp
S
delta
K
1000 - S
95* 4/5
cp = b * S - muS * S - (r * (S^2) / K)
cp
ap = (-b2 - b3 * delta - b3 * delta - b3 * (delta^2)) * r / K
ap
delta = gamma / (epsilon + muR)#
		ap = (-b2 - b3 * delta - b3 * delta - b3 * (delta^2)) * r / K#
		bp = b * b2 + b * b3 * delta - betaB * S - #
			(r / K) * (S + S * delta + b2 *S + b3 * delta * S)#
		cp = b * S - muS * S - (r * (S^2) / K)
ap
bp
cp
bp^2 - 4 * ap * cp
bp^2
I1 = 0.5 * (- bp + sqrt(bp^2 - 4 * ap * cp )) / ap
I2 = 0.5 * (- bp - sqrt(bp^2 - 4 * ap * cp )) / ap
I1
I2
I = max(I1, I2)
get_x_analytic_endemic_brucellosis = function(params, RoB= RoB){ #
	with(as.list(c(params)), {#
		S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon + muR)#
		ap = (-b2 - b3 * delta - b3 * delta - b3 * (delta^2)) * r / K#
		bp = b * b2 + b * b3 * delta - betaB * S - #
			(r / K) * (S + S * delta + b2 *S + b3 * delta * S)#
		cp = b * S - muS * S - (r * (S^2) / K)#
		I1 = 0.5 * (- bp + sqrt(bp^2 - 4 * ap * cp )) / ap#
		I2 = 0.5 * (- bp - sqrt(bp^2 - 4 * ap * cp )) / ap #
		I = max(I1, I2)#
		# R is a ratio of I#
		R = I * delta#
#
		x = c(S= S, I = I, R = R)#
	return(x)#
	}#
	)#
}#
x = get_x_analytic_endemic_brucellosis(params)
I
R = I * delta
R
32 + 7 + S
S
params
params = c(params.fixed, betaB= 0.0007853113, betaT = 0.0003092429, rhoT = 1.3, rhoB = 4.05)#check,gamma=0.5
params
get_x_analytic_endemic_brucellosis = function(params, RoB= RoB){ #
	with(as.list(c(params)), {#
		S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon + muR)#
		ap = (-b2 - b3 * delta - b3 * delta - b3 * (delta^2)) * r / K#
		bp = b * b2 + b * b3 * delta - betaB * S - #
			(r / K) * (S + S * delta + b2 *S + b3 * delta * S)#
		cp = b * S - muS * S - (r * (S^2) / K)#
		I1 = 0.5 * (- bp + sqrt(bp^2 - 4 * ap * cp )) / ap#
		I2 = 0.5 * (- bp - sqrt(bp^2 - 4 * ap * cp )) / ap #
		I = max(I1, I2)#
		# R is a ratio of I#
		R = I * delta#
#
		x = c(S= S, I = I, R = R)#
	return(x)#
	}#
	)#
}#
x = get_x_analytic_endemic_brucellosis(params)
S = K / RoB#
		# solve polynomial to get I #
		delta = gamma / (epsilon + muR)#
		ap = (-b2 - b3 * delta - b3 * delta - b3 * (delta^2)) * r / K#
		bp = b * b2 + b * b3 * delta - betaB * S - #
			(r / K) * (S + S * delta + b2 *S + b3 * delta * S)#
		cp = b * S - muS * S - (r * (S^2) / K)#
		I1 = 0.5 * (- bp + sqrt(bp^2 - 4 * ap * cp )) / ap#
		I2 = 0.5 * (- bp - sqrt(bp^2 - 4 * ap * cp )) / ap #
		I = max(I1, I2)#
		# R is a ratio of I#
		R = I * delta#
#
		x = c(S= S, I = I, R = R)
x
RoTBwithC(params = params, x = x)
params
betapT = rhoB * betaB#
		batapB = rhoT * betaT
Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)#
		return(Ro)
rhoB = params['rhoB']
rhoT = params['rhoT']
betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)
betapT
rhoB = params[['rhoB']]
rhoT = params[['rhoT']]
betapT = rhoB * betaB#
		batapB = rhoT * betaT#
		Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)
betapT
betapB
betapT = rhoT * betaT
batapB = rhoB * betaB
betapB
betaB
rhoB
betapB = rhoB * betaB
Ro = (betapT * R) / (I * betapB + muT) + #
		(betapT * R * betapB * I * (muRC + epsilon)) / ((I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma)) +#
		(betapT * R * betapB * I * gamma) / ( (I * betapB + muT) * (muC * muRC + muC * epsilon + muRC * gamma) ) + #
		((betapT * R * (muRC + epsilon)) / (muC * muRC + muC * epsilon + muRC * gamma)) *#
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		((betapT * R * gamma) / (muC * muRC + muC * epsilon + muRC * gamma)) * #
		((betapT * R * epsilon) / (muC * muRC + muC * epsilon + muRC * gamma)) + #
		(betapT * R * (gamma + muC)) / (muC * muRC + muC * epsilon + muRC * gamma)
Rp
Ro
